// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package tutorial

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addNewTags = `-- name: AddNewTags :exec
INSERT INTO tags (name)
SELECT new_tags FROM UNNEST($1::text[]) AS new_tags
WHERE new_tags NOT IN (
    SELECT name
    FROM tags
    WHERE name = new_tags)
ON CONFLICT DO NOTHING
`

// Adds new tags to the database if they do not already exist.
func (q *Queries) AddNewTags(ctx context.Context, tagarray []string) error {
	_, err := q.db.Exec(ctx, addNewTags, tagarray)
	return err
}

const addThreadTags = `-- name: AddThreadTags :exec
INSERT INTO thread_tags (thread_id, tag_name)
SELECT $1 as thread_id,
       unnest($2::text[]) as tag_name
ON CONFLICT DO NOTHING
`

type AddThreadTagsParams struct {
	ThreadID pgtype.UUID `json:"thread_id"`
	Tagarray []string    `json:"tagarray"`
}

// Adds tags to a thread if they do not already exist.
func (q *Queries) AddThreadTags(ctx context.Context, arg AddThreadTagsParams) error {
	_, err := q.db.Exec(ctx, addThreadTags, arg.ThreadID, arg.Tagarray)
	return err
}

const checkCommentCreator = `-- name: CheckCommentCreator :one
SELECT EXISTS
    (SELECT 1 FROM comments WHERE id = $1 AND creator = $2)
AS is_comment_creator
`

type CheckCommentCreatorParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Checks if a user is the creator of a comment.
func (q *Queries) CheckCommentCreator(ctx context.Context, arg CheckCommentCreatorParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCommentCreator, arg.ID, arg.Creator)
	var is_comment_creator bool
	err := row.Scan(&is_comment_creator)
	return is_comment_creator, err
}

const checkThreadCreator = `-- name: CheckThreadCreator :one
SELECT EXISTS
    (SELECT 1 FROM threads WHERE id = $1 AND creator = $2)
AS is_thread_creator
`

type CheckThreadCreatorParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Checks if a user is the creator of a thread.
func (q *Queries) CheckThreadCreator(ctx context.Context, arg CheckThreadCreatorParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkThreadCreator, arg.ID, arg.Creator)
	var is_thread_creator bool
	err := row.Scan(&is_thread_creator)
	return is_thread_creator, err
}

const checkUserExists = `-- name: CheckUserExists :one

SELECT EXISTS
    (SELECT 1 FROM users WHERE LOWER(username) = LOWER($1))
AS is_existing_user
`

// Queries for sqlc to generate Go code.
// docker run --rm -v "%cd%:/src" -w /src sqlc/sqlc generate
// Returns 1 if the user with the given username exists.
func (q *Queries) CheckUserExists(ctx context.Context, lower string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExists, lower)
	var is_existing_user bool
	err := row.Scan(&is_existing_user)
	return is_existing_user, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (body, creator, thread_id)
VALUES ($1, $2, $3)
RETURNING id, body, creator, thread_id, created_time, updated_time
`

type CreateCommentParams struct {
	Body     string      `json:"body"`
	Creator  string      `json:"creator"`
	ThreadID pgtype.UUID `json:"thread_id"`
}

// Creates a new comment with the given body, creator, and thread_id. Returns the details of the created comment.
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Body, arg.Creator, arg.ThreadID)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.Creator,
		&i.ThreadID,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const createThread = `-- name: CreateThread :one
INSERT INTO threads (title, body, creator)
VALUES ($1, $2, $3)
RETURNING id, title, body, creator, created_time, updated_time, num_comments
`

type CreateThreadParams struct {
	Title   string `json:"title"`
	Body    string `json:"body"`
	Creator string `json:"creator"`
}

// Creates a new thread with the given title, body, and creator. Returns the details of the created thread.
func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (Thread, error) {
	row := q.db.QueryRow(ctx, createThread, arg.Title, arg.Body, arg.Creator)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Creator,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.NumComments,
	)
	return i, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, password)
VALUES ($1, $2)
`

type CreateUserParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// Creates a new user with the given username and password.
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.Username, arg.Password)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments
WHERE id = $1
AND creator = $2
`

type DeleteCommentParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Deletes the comment with the given id.
func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.Creator)
	return err
}

const deleteThread = `-- name: DeleteThread :exec
DELETE FROM threads
WHERE id = $1
AND creator = $2
`

type DeleteThreadParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Deletes the thread with the given id.
func (q *Queries) DeleteThread(ctx context.Context, arg DeleteThreadParams) error {
	_, err := q.db.Exec(ctx, deleteThread, arg.ID, arg.Creator)
	return err
}

const deleteThreadTags = `-- name: DeleteThreadTags :exec
DELETE FROM thread_tags
WHERE thread_id = $1
`

// Deletes all tags of the thread with the given id.
func (q *Queries) DeleteThreadTags(ctx context.Context, threadID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteThreadTags, threadID)
	return err
}

const deleteUnusedTags = `-- name: DeleteUnusedTags :exec
DELETE FROM tags
WHERE name NOT IN (
    SELECT DISTINCT tag_name
    FROM thread_tags
)
`

// Deletes tags that are not associated with any threads.
func (q *Queries) DeleteUnusedTags(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteUnusedTags)
	return err
}

const getCommentCount = `-- name: GetCommentCount :one
SELECT COUNT(*) AS total_items
FROM comments
WHERE thread_id = $1
`

// Counts the total number of comments for a thread.
func (q *Queries) GetCommentCount(ctx context.Context, threadID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getCommentCount, threadID)
	var total_items int64
	err := row.Scan(&total_items)
	return total_items, err
}

const getComments = `-- name: GetComments :many
SELECT id, body, creator, thread_id, created_time, updated_time
FROM comments
WHERE thread_id = $1
ORDER BY
    CASE WHEN $4::text = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $4::text = 'created_time_desc' THEN created_time END DESC
LIMIT $2
OFFSET $3
`

type GetCommentsParams struct {
	ThreadID  pgtype.UUID `json:"thread_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Sortorder string      `json:"sortorder"`
}

// Get comments for a thread.
// Sort order should be one of 'created_time_asc', 'created_time_desc'.
func (q *Queries) GetComments(ctx context.Context, arg GetCommentsParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getComments,
		arg.ThreadID,
		arg.Limit,
		arg.Offset,
		arg.Sortorder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Comment{}
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.Creator,
			&i.ThreadID,
			&i.CreatedTime,
			&i.UpdatedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPasswordHash = `-- name: GetPasswordHash :one
SELECT username, password
FROM users
WHERE LOWER(username) = LOWER($1)
`

// Returns a user's password hash.
func (q *Queries) GetPasswordHash(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getPasswordHash, lower)
	var i User
	err := row.Scan(&i.Username, &i.Password)
	return i, err
}

const getThreadDetails = `-- name: GetThreadDetails :one
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    CASE
    WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name ORDER BY tt.tag_name)
        ELSE '{}'::text[]
    END AS tags
FROM threads t
LEFT JOIN thread_tags tt ON t.id = tt.thread_id
WHERE t.id = $1
GROUP BY t.id
`

type GetThreadDetailsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the details of the thread with the given id, as well as the tags of the thread as an array.
func (q *Queries) GetThreadDetails(ctx context.Context, id pgtype.UUID) (GetThreadDetailsRow, error) {
	row := q.db.QueryRow(ctx, getThreadDetails, id)
	var i GetThreadDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Creator,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.NumComments,
		&i.Tags,
	)
	return i, err
}

const getThreadTags = `-- name: GetThreadTags :many
SELECT tag_name
FROM thread_tags
WHERE thread_id = $1
`

// Returns the tags of the thread with the given id.
func (q *Queries) GetThreadTags(ctx context.Context, threadID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getThreadTags, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var tag_name string
		if err := rows.Scan(&tag_name); err != nil {
			return nil, err
		}
		items = append(items, tag_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreads = `-- name: GetThreads :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    CASE
    WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name ORDER BY tt.tag_name)
        ELSE '{}'::text[]
    END AS tags
FROM threads t
LEFT JOIN thread_tags tt ON t.id = tt.thread_id
GROUP BY t.id
ORDER BY
    CASE WHEN $3::text = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $3::text = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $3::text = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $3::text = 'num_comments_desc' THEN num_comments END DESC
LIMIT $1
OFFSET $2
`

type GetThreadsParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Sortorder string `json:"sortorder"`
}

type GetThreadsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the details of all threads.
// Sort order should be one of 'created_time_asc', 'created_time_desc', 'num_comments_asc', 'num_comments_desc'.
func (q *Queries) GetThreads(ctx context.Context, arg GetThreadsParams) ([]GetThreadsRow, error) {
	rows, err := q.db.Query(ctx, getThreads, arg.Limit, arg.Offset, arg.Sortorder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetThreadsRow{}
	for rows.Next() {
		var i GetThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByCriteria = `-- name: GetThreadsByCriteria :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    -- Concatenate all the tags of the thread into an array.
    CASE
       WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name ORDER BY tt.tag_name)
       ELSE '{}'::text[]
    END AS tags
FROM threads t
LEFT JOIN thread_tags tt ON t.id = tt.thread_id
WHERE
    -- Handle the case where the keyword is empty (NULL).
    CASE
        WHEN LENGTH($3::text) > 0 THEN TO_TSVECTOR('simple', t.title || ' ' || t.body) @@ TO_TSQUERY
('simple', $3::text)
        ELSE TRUE
    END
AND
    -- Handle the case where the tag array is empty.
    CASE
        WHEN ARRAY_LENGTH($4::text[], 1) > 0 THEN t.id IN (
            SELECT tt.thread_id
            FROM thread_tags tt
            WHERE tt.tag_name = ANY($4::text[])
            GROUP BY tt.thread_id
            HAVING COUNT(DISTINCT tt.tag_name) = ARRAY_LENGTH($4::text[], 1)
        )
        ELSE TRUE
    END
GROUP BY t.id
ORDER BY
    CASE WHEN $5::text = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $5::text = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $5::text = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $5::text = 'num_comments_desc' THEN num_comments END DESC
LIMIT $1
OFFSET $2
`

type GetThreadsByCriteriaParams struct {
	Limit     int32    `json:"limit"`
	Offset    int32    `json:"offset"`
	Keywords  string   `json:"keywords"`
	Tagarray  []string `json:"tagarray"`
	Sortorder string   `json:"sortorder"`
}

type GetThreadsByCriteriaRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the threads that match the keywords and tags.
// If the keyword is provided, only threads that match all the keywords will be returned.
// If the tags are provided, only threads that match all the tags will be returned.
func (q *Queries) GetThreadsByCriteria(ctx context.Context, arg GetThreadsByCriteriaParams) ([]GetThreadsByCriteriaRow, error) {
	rows, err := q.db.Query(ctx, getThreadsByCriteria,
		arg.Limit,
		arg.Offset,
		arg.Keywords,
		arg.Tagarray,
		arg.Sortorder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetThreadsByCriteriaRow{}
	for rows.Next() {
		var i GetThreadsByCriteriaRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByCriteriaCount = `-- name: GetThreadsByCriteriaCount :one
SELECT COUNT(*) AS total_items
FROM threads t
WHERE
    CASE
        WHEN LENGTH($1::text) > 0 THEN TO_TSVECTOR('simple', t.title || ' ' || t.body) @@ TO_TSQUERY('simple', $1::text)
        ELSE TRUE
    END
  AND
    CASE
        WHEN ARRAY_LENGTH($2::text[], 1) > 0 THEN t.id IN (
          SELECT tt.thread_id
          FROM thread_tags tt
          WHERE tt.tag_name = ANY($2::text[])
          GROUP BY tt.thread_id
          HAVING COUNT(DISTINCT tt.tag_name) = ARRAY_LENGTH($2::text[], 1)
        )
        ELSE TRUE
    END
`

type GetThreadsByCriteriaCountParams struct {
	Keywords string   `json:"keywords"`
	Tagarray []string `json:"tagarray"`
}

// Counts the total number of threads that match the keywords and tags.
func (q *Queries) GetThreadsByCriteriaCount(ctx context.Context, arg GetThreadsByCriteriaCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getThreadsByCriteriaCount, arg.Keywords, arg.Tagarray)
	var total_items int64
	err := row.Scan(&total_items)
	return total_items, err
}

const updateComment = `-- name: UpdateComment :exec
UPDATE comments
SET body = $1, updated_time = NOW()
WHERE id = $2
AND creator = $3
`

type UpdateCommentParams struct {
	Body    string      `json:"body"`
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Updates the comment with the given id.
func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment, arg.Body, arg.ID, arg.Creator)
	return err
}

const updateThread = `-- name: UpdateThread :exec
UPDATE threads
SET title = $1, body = $2, updated_time = NOW()
WHERE id = $3
AND creator = $4
`

type UpdateThreadParams struct {
	Title   string      `json:"title"`
	Body    string      `json:"body"`
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Updates the thread with the given id.
func (q *Queries) UpdateThread(ctx context.Context, arg UpdateThreadParams) error {
	_, err := q.db.Exec(ctx, updateThread,
		arg.Title,
		arg.Body,
		arg.ID,
		arg.Creator,
	)
	return err
}
