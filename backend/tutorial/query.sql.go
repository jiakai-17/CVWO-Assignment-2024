// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package tutorial

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addThreadTag = `-- name: AddThreadTag :exec
INSERT INTO thread_tags (thread_id, tag_name)
VALUES ($1, $2)
`

type AddThreadTagParams struct {
	ThreadID pgtype.UUID `json:"thread_id"`
	TagName  string      `json:"tag_name"`
}

// Adds a tag to the thread.
func (q *Queries) AddThreadTag(ctx context.Context, arg AddThreadTagParams) error {
	_, err := q.db.Exec(ctx, addThreadTag, arg.ThreadID, arg.TagName)
	return err
}

const checkCommentCreator = `-- name: CheckCommentCreator :one
SELECT EXISTS
    (SELECT 1 FROM comments WHERE id = $1 AND creator = $2)
AS is_comment_creator
`

type CheckCommentCreatorParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Checks if a user is the creator of a comment.
func (q *Queries) CheckCommentCreator(ctx context.Context, arg CheckCommentCreatorParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCommentCreator, arg.ID, arg.Creator)
	var is_comment_creator bool
	err := row.Scan(&is_comment_creator)
	return is_comment_creator, err
}

const checkThreadCreator = `-- name: CheckThreadCreator :one
SELECT EXISTS
    (SELECT 1 FROM threads WHERE id = $1 AND creator = $2)
AS is_thread_creator
`

type CheckThreadCreatorParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Checks if a user is the creator of a thread.
func (q *Queries) CheckThreadCreator(ctx context.Context, arg CheckThreadCreatorParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkThreadCreator, arg.ID, arg.Creator)
	var is_thread_creator bool
	err := row.Scan(&is_thread_creator)
	return is_thread_creator, err
}

const checkUserExists = `-- name: CheckUserExists :one

SELECT EXISTS
    (SELECT 1 FROM users WHERE LOWER(username) = LOWER($1))
AS is_existing_user
`

// Queries for sqlc to generate Go code.
// docker run --rm -v "%cd%:/src" -w /src sqlc/sqlc generate
// Returns 1 if the user with the given username exists.
func (q *Queries) CheckUserExists(ctx context.Context, lower string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExists, lower)
	var is_existing_user bool
	err := row.Scan(&is_existing_user)
	return is_existing_user, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (body, creator, thread_id)
VALUES ($1, $2, $3)
RETURNING id, body, creator, thread_id, created_time, updated_time
`

type CreateCommentParams struct {
	Body     string      `json:"body"`
	Creator  string      `json:"creator"`
	ThreadID pgtype.UUID `json:"thread_id"`
}

// Creates a new comment with the given body, creator, and thread_id. Returns the details of the created comment.
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Body, arg.Creator, arg.ThreadID)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.Creator,
		&i.ThreadID,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const createThread = `-- name: CreateThread :one
INSERT INTO threads (title, body, creator)
VALUES ($1, $2, $3)
RETURNING id, title, body, creator, created_time, updated_time, num_comments
`

type CreateThreadParams struct {
	Title   string `json:"title"`
	Body    string `json:"body"`
	Creator string `json:"creator"`
}

// Creates a new thread with the given title, body, and creator. Returns the details of the created thread.
func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (Thread, error) {
	row := q.db.QueryRow(ctx, createThread, arg.Title, arg.Body, arg.Creator)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Creator,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.NumComments,
	)
	return i, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, password)
VALUES ($1, $2)
`

type CreateUserParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// Creates a new user with the given username and password.
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.Username, arg.Password)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments
WHERE id = $1
AND creator = $2
`

type DeleteCommentParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Deletes the comment with the given id.
func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.Creator)
	return err
}

const deleteThread = `-- name: DeleteThread :exec
DELETE FROM threads
WHERE id = $1
AND creator = $2
`

type DeleteThreadParams struct {
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Deletes the thread with the given id.
func (q *Queries) DeleteThread(ctx context.Context, arg DeleteThreadParams) error {
	_, err := q.db.Exec(ctx, deleteThread, arg.ID, arg.Creator)
	return err
}

const deleteThreadTag = `-- name: DeleteThreadTag :exec
DELETE FROM thread_tags
WHERE thread_id = $1
AND tag_name = $2
`

type DeleteThreadTagParams struct {
	ThreadID pgtype.UUID `json:"thread_id"`
	TagName  string      `json:"tag_name"`
}

// Removes the tag from the thread.
func (q *Queries) DeleteThreadTag(ctx context.Context, arg DeleteThreadTagParams) error {
	_, err := q.db.Exec(ctx, deleteThreadTag, arg.ThreadID, arg.TagName)
	return err
}

const getComments = `-- name: GetComments :many
SELECT id, body, creator, thread_id, created_time, updated_time
FROM comments
WHERE thread_id = $1
ORDER BY
    CASE WHEN $4::text = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $4::text = 'created_time_desc' THEN created_time END DESC
LIMIT $2
OFFSET $3
`

type GetCommentsParams struct {
	ThreadID  pgtype.UUID `json:"thread_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Sortorder string      `json:"sortorder"`
}

// Get comments for a thread.
// Sort order should be one of 'created_time_asc', 'created_time_desc'.
func (q *Queries) GetComments(ctx context.Context, arg GetCommentsParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getComments,
		arg.ThreadID,
		arg.Limit,
		arg.Offset,
		arg.Sortorder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.Creator,
			&i.ThreadID,
			&i.CreatedTime,
			&i.UpdatedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPasswordHash = `-- name: GetPasswordHash :one
SELECT username, password
FROM users
WHERE LOWER(username) = LOWER($1)
`

// Returns a user's password hash.
func (q *Queries) GetPasswordHash(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getPasswordHash, lower)
	var i User
	err := row.Scan(&i.Username, &i.Password)
	return i, err
}

const getThreadDetails = `-- name: GetThreadDetails :one
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    CASE
    WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name)
        ELSE '{}'::text[]
    END AS tags
FROM threads t
LEFT JOIN thread_tags tt ON t.id = tt.thread_id
WHERE t.id = $1
GROUP BY t.id
`

type GetThreadDetailsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the details of the thread with the given id, as well as the tags of the thread as an array.
func (q *Queries) GetThreadDetails(ctx context.Context, id pgtype.UUID) (GetThreadDetailsRow, error) {
	row := q.db.QueryRow(ctx, getThreadDetails, id)
	var i GetThreadDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Creator,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.NumComments,
		&i.Tags,
	)
	return i, err
}

const getThreadTags = `-- name: GetThreadTags :many
SELECT tag_name
FROM thread_tags
WHERE thread_id = $1
`

// Returns the tags of the thread with the given id.
func (q *Queries) GetThreadTags(ctx context.Context, threadID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getThreadTags, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag_name string
		if err := rows.Scan(&tag_name); err != nil {
			return nil, err
		}
		items = append(items, tag_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreads = `-- name: GetThreads :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    CASE
    WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name)
        ELSE '{}'::text[]
    END AS tags
FROM threads t
LEFT JOIN thread_tags tt ON t.id = tt.thread_id
GROUP BY t.id
ORDER BY
    CASE WHEN $3::text = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $3::text = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $3::text = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $3::text = 'num_comments_desc' THEN num_comments END DESC
LIMIT $1
OFFSET $2
`

type GetThreadsParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Sortorder string `json:"sortorder"`
}

type GetThreadsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the details of all threads.
// Sort order should be one of 'created_time_asc', 'created_time_desc', 'num_comments_asc', 'num_comments_desc'.
func (q *Queries) GetThreads(ctx context.Context, arg GetThreadsParams) ([]GetThreadsRow, error) {
	rows, err := q.db.Query(ctx, getThreads, arg.Limit, arg.Offset, arg.Sortorder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsRow
	for rows.Next() {
		var i GetThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByMultipleKeyword = `-- name: GetThreadsByMultipleKeyword :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    CASE
    WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name)
        ELSE '{}'::text[]
    END AS tags
FROM threads t
LEFT JOIN thread_tags tt ON t.id = tt.thread_id
WHERE TO_TSVECTOR('simple', t.title || ' ' || t.body) @@ TO_TSQUERY('simple', $3::text)
GROUP BY t.id
ORDER BY
    CASE WHEN $4::text = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $4::text = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $4::text = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $4::text = 'num_comments_desc' THEN num_comments END DESC
LIMIT $1
OFFSET $2
`

type GetThreadsByMultipleKeywordParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Keywords  string `json:"keywords"`
	Sortorder string `json:"sortorder"`
}

type GetThreadsByMultipleKeywordRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the details of threads that match all the given keywords.
// Keywords should be a single string, with each word separated by &.
// Sort order should be one of 'created_time_asc', 'created_time_desc', 'num_comments_asc', 'num_comments_desc'.
func (q *Queries) GetThreadsByMultipleKeyword(ctx context.Context, arg GetThreadsByMultipleKeywordParams) ([]GetThreadsByMultipleKeywordRow, error) {
	rows, err := q.db.Query(ctx, getThreadsByMultipleKeyword,
		arg.Limit,
		arg.Offset,
		arg.Keywords,
		arg.Sortorder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsByMultipleKeywordRow
	for rows.Next() {
		var i GetThreadsByMultipleKeywordRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByMultipleTags = `-- name: GetThreadsByMultipleTags :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    CASE
    WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name)
        ELSE '{}'::text[]
    END AS tags
FROM threads t
INNER JOIN thread_tags tt ON t.id = tt.thread_id
WHERE tt.tag_name = ANY($3::text[])
GROUP BY t.id
HAVING COUNT(DISTINCT tt.tag_name) = ARRAY_LENGTH($3::text[], 1)
ORDER BY
    CASE WHEN $4::text = 'created_time_asc' THEN t.created_time END ASC,
    CASE WHEN $4::text = 'created_time_desc' THEN t.created_time END DESC,
    CASE WHEN $4::text = 'num_comments_asc' THEN t.num_comments END ASC,
    CASE WHEN $4::text = 'num_comments_desc' THEN t.num_comments END DESC
LIMIT $1
OFFSET $2
`

type GetThreadsByMultipleTagsParams struct {
	Limit     int32    `json:"limit"`
	Offset    int32    `json:"offset"`
	Tagarray  []string `json:"tagarray"`
	Sortorder string   `json:"sortorder"`
}

type GetThreadsByMultipleTagsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the details of threads that match all the given tags.
// Sort order should be one of 'created_time_asc', 'created_time_desc', 'num_comments_asc', 'num_comments_desc'.
func (q *Queries) GetThreadsByMultipleTags(ctx context.Context, arg GetThreadsByMultipleTagsParams) ([]GetThreadsByMultipleTagsRow, error) {
	rows, err := q.db.Query(ctx, getThreadsByMultipleTags,
		arg.Limit,
		arg.Offset,
		arg.Tagarray,
		arg.Sortorder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsByMultipleTagsRow
	for rows.Next() {
		var i GetThreadsByMultipleTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByMultipleTagsAndKeyword = `-- name: GetThreadsByMultipleTagsAndKeyword :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments,
    CASE
    WHEN COUNT(tt.tag_name) > 0 THEN ARRAY_AGG(tt.tag_name)
        ELSE '{}'::text[]
    END AS tags
FROM threads t
LEFT JOIN thread_tags tt ON t.id = tt.thread_id
WHERE TO_TSVECTOR('simple', t.title || ' ' || t.body) @@ TO_TSQUERY('simple', $3::text)
AND tt.tag_name = ANY($4::text[])
GROUP BY t.id
HAVING COUNT(DISTINCT tt.tag_name) = array_length($4::text[], 1)
ORDER BY
    CASE WHEN $5::text = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $5::text = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $5::text = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $5::text = 'num_comments_desc' THEN num_comments END DESC
LIMIT $1
OFFSET $2
`

type GetThreadsByMultipleTagsAndKeywordParams struct {
	Limit     int32    `json:"limit"`
	Offset    int32    `json:"offset"`
	Keywords  string   `json:"keywords"`
	Tagarray  []string `json:"tagarray"`
	Sortorder string   `json:"sortorder"`
}

type GetThreadsByMultipleTagsAndKeywordRow struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Creator     string             `json:"creator"`
	CreatedTime pgtype.Timestamptz `json:"created_time"`
	UpdatedTime pgtype.Timestamptz `json:"updated_time"`
	NumComments int32              `json:"num_comments"`
	Tags        []string           `json:"tags"`
}

// Returns the details of threads that match all the given tags and keywords.
// Keywords should be a single string, with each word separated by &.
// Sort order should be one of 'created_time_asc', 'created_time_desc', 'num_comments_asc', 'num_comments_desc'.
func (q *Queries) GetThreadsByMultipleTagsAndKeyword(ctx context.Context, arg GetThreadsByMultipleTagsAndKeywordParams) ([]GetThreadsByMultipleTagsAndKeywordRow, error) {
	rows, err := q.db.Query(ctx, getThreadsByMultipleTagsAndKeyword,
		arg.Limit,
		arg.Offset,
		arg.Keywords,
		arg.Tagarray,
		arg.Sortorder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsByMultipleTagsAndKeywordRow
	for rows.Next() {
		var i GetThreadsByMultipleTagsAndKeywordRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :exec
UPDATE comments
SET body = $1, updated_time = NOW()
WHERE id = $2
AND creator = $3
`

type UpdateCommentParams struct {
	Body    string      `json:"body"`
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Updates the comment with the given id.
func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment, arg.Body, arg.ID, arg.Creator)
	return err
}

const updateThread = `-- name: UpdateThread :exec
UPDATE threads
SET title = $1, body = $2, updated_time = NOW()
WHERE id = $3
AND creator = $4
`

type UpdateThreadParams struct {
	Title   string      `json:"title"`
	Body    string      `json:"body"`
	ID      pgtype.UUID `json:"id"`
	Creator string      `json:"creator"`
}

// Updates the thread with the given id.
func (q *Queries) UpdateThread(ctx context.Context, arg UpdateThreadParams) error {
	_, err := q.db.Exec(ctx, updateThread,
		arg.Title,
		arg.Body,
		arg.ID,
		arg.Creator,
	)
	return err
}
