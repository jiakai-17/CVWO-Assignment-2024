// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package tutorial

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addThreadTag = `-- name: AddThreadTag :exec
INSERT INTO thread_tags (thread_id, tag_name)
VALUES ($1, $2)
`

type AddThreadTagParams struct {
	ThreadID pgtype.UUID
	TagName  string
}

func (q *Queries) AddThreadTag(ctx context.Context, arg AddThreadTagParams) error {
	_, err := q.db.Exec(ctx, addThreadTag, arg.ThreadID, arg.TagName)
	return err
}

const checkUserExists = `-- name: CheckUserExists :one

SELECT 1
FROM users
WHERE username = $1
`

// ----- USER QUERIES -----
func (q *Queries) CheckUserExists(ctx context.Context, username string) (int32, error) {
	row := q.db.QueryRow(ctx, checkUserExists, username)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createComment = `-- name: CreateComment :one

INSERT INTO comments (body, creator, thread_id)
VALUES ($1, $2, $3)
RETURNING id, body, creator, thread_id, created_time, updated_time
`

type CreateCommentParams struct {
	Body     string
	Creator  string
	ThreadID pgtype.UUID
}

// ----- COMMENT QUERIES -----
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Body, arg.Creator, arg.ThreadID)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.Creator,
		&i.ThreadID,
		&i.CreatedTime,
		&i.UpdatedTime,
	)
	return i, err
}

const createThread = `-- name: CreateThread :one

INSERT INTO threads (title, body, creator)
VALUES ($1, $2, $3)
RETURNING id, title, body, creator, created_time, updated_time, num_comments
`

type CreateThreadParams struct {
	Title   string
	Body    string
	Creator string
}

// ----- THREAD QUERIES -----
func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (Thread, error) {
	row := q.db.QueryRow(ctx, createThread, arg.Title, arg.Body, arg.Creator)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Creator,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.NumComments,
	)
	return i, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, password)
VALUES ($1, $2)
`

type CreateUserParams struct {
	Username string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.Username, arg.Password)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments
WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteComment, id)
	return err
}

const deleteThread = `-- name: DeleteThread :exec
DELETE FROM threads
WHERE id = $1
`

func (q *Queries) DeleteThread(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteThread, id)
	return err
}

const deleteThreadTag = `-- name: DeleteThreadTag :exec
DELETE FROM thread_tags
WHERE thread_id = $1 AND tag_name = $2
`

type DeleteThreadTagParams struct {
	ThreadID pgtype.UUID
	TagName  string
}

func (q *Queries) DeleteThreadTag(ctx context.Context, arg DeleteThreadTagParams) error {
	_, err := q.db.Exec(ctx, deleteThreadTag, arg.ThreadID, arg.TagName)
	return err
}

const getComments = `-- name: GetComments :many
SELECT id, body, creator, thread_id, created_time, updated_time
FROM comments
WHERE thread_id = $1
ORDER BY
    CASE WHEN $2 = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $2 = 'created_time_desc' THEN created_time END DESC
LIMIT $3
OFFSET $4
`

type GetCommentsParams struct {
	ThreadID pgtype.UUID
	Column2  interface{}
	Limit    int32
	Offset   int32
}

func (q *Queries) GetComments(ctx context.Context, arg GetCommentsParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getComments,
		arg.ThreadID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.Creator,
			&i.ThreadID,
			&i.CreatedTime,
			&i.UpdatedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPasswordHash = `-- name: GetPasswordHash :one
SELECT password
FROM users
WHERE username = $1
`

func (q *Queries) GetPasswordHash(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, getPasswordHash, username)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getThreadDetails = `-- name: GetThreadDetails :one
SELECT id, title, body, creator, created_time, updated_time, num_comments
FROM threads
WHERE id = $1
`

func (q *Queries) GetThreadDetails(ctx context.Context, id pgtype.UUID) (Thread, error) {
	row := q.db.QueryRow(ctx, getThreadDetails, id)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Creator,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.NumComments,
	)
	return i, err
}

const getThreadTags = `-- name: GetThreadTags :many
SELECT tag_name
FROM thread_tags
WHERE thread_id = $1
`

func (q *Queries) GetThreadTags(ctx context.Context, threadID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getThreadTags, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag_name string
		if err := rows.Scan(&tag_name); err != nil {
			return nil, err
		}
		items = append(items, tag_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreads = `-- name: GetThreads :many
SELECT id, title, body, creator, created_time, updated_time, num_comments
FROM threads
ORDER BY
    CASE WHEN $1 = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $1 = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $1 = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $1 = 'num_comments_desc' THEN num_comments END DESC
LIMIT $2
OFFSET $3
`

type GetThreadsParams struct {
	Column1 interface{}
	Limit   int32
	Offset  int32
}

func (q *Queries) GetThreads(ctx context.Context, arg GetThreadsParams) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getThreads, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByMultipleKeyword = `-- name: GetThreadsByMultipleKeyword :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments
FROM threads t
WHERE to_tsvector('simple', title || ' ' || body) @@ to_tsquery('simple', $1)
ORDER BY
    CASE WHEN $2 = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $2 = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $2 = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $2 = 'num_comments_desc' THEN num_comments END DESC
LIMIT $3
OFFSET $4
`

type GetThreadsByMultipleKeywordParams struct {
	ToTsquery string
	Column2   interface{}
	Limit     int32
	Offset    int32
}

// Join keywords with '&'
func (q *Queries) GetThreadsByMultipleKeyword(ctx context.Context, arg GetThreadsByMultipleKeywordParams) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getThreadsByMultipleKeyword,
		arg.ToTsquery,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByMultipleTags = `-- name: GetThreadsByMultipleTags :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments
FROM threads t
INNER JOIN thread_tags tt ON t.id = tt.thread_id
WHERE tt.tag_name IN ($1)
GROUP BY t.id
HAVING COUNT(*) = $2
ORDER BY
    CASE WHEN $3 = 'created_time_asc' THEN created_time END ASC,
    CASE WHEN $3 = 'created_time_desc' THEN created_time END DESC,
    CASE WHEN $3 = 'num_comments_asc' THEN num_comments END ASC,
    CASE WHEN $3 = 'num_comments_desc' THEN num_comments END DESC
LIMIT $4
OFFSET $5
`

type GetThreadsByMultipleTagsParams struct {
	TagName string
	Column2 interface{}
	Column3 interface{}
	Limit   int32
	Offset  int32
}

func (q *Queries) GetThreadsByMultipleTags(ctx context.Context, arg GetThreadsByMultipleTagsParams) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getThreadsByMultipleTags,
		arg.TagName,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadsByMultipleTagsv2 = `-- name: GetThreadsByMultipleTagsv2 :many
SELECT t.id, t.title, t.body, t.creator, t.created_time, t.updated_time, t.num_comments
FROM threads t
INNER JOIN thread_tags tt ON t.id = tt.thread_id
WHERE tt.tag_name = ANY($1)
GROUP BY t.id
HAVING COUNT(DISTINCT tt.tag_name) = array_length($1, 1)  -- Count the distinct tags to match all provided tags
ORDER BY
    CASE WHEN $2 = 'created_time_asc' THEN t.created_time END ASC,
    CASE WHEN $2 = 'created_time_desc' THEN t.created_time END DESC,
    CASE WHEN $2 = 'num_comments_asc' THEN t.num_comments END ASC,
    CASE WHEN $2 = 'num_comments_desc' THEN t.num_comments END DESC
LIMIT $3
OFFSET $4
`

type GetThreadsByMultipleTagsv2Params struct {
	TagName []string
	Column2 interface{}
	Limit   int32
	Offset  int32
}

func (q *Queries) GetThreadsByMultipleTagsv2(ctx context.Context, arg GetThreadsByMultipleTagsv2Params) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getThreadsByMultipleTagsv2,
		arg.TagName,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Creator,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.NumComments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :exec
UPDATE comments
SET body = $1, updated_time = NOW()
WHERE id = $2
`

type UpdateCommentParams struct {
	Body string
	ID   pgtype.UUID
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment, arg.Body, arg.ID)
	return err
}

const updateThread = `-- name: UpdateThread :exec
UPDATE threads
SET title = $1, body = $2, updated_time = NOW()
WHERE id = $3
`

type UpdateThreadParams struct {
	Title string
	Body  string
	ID    pgtype.UUID
}

func (q *Queries) UpdateThread(ctx context.Context, arg UpdateThreadParams) error {
	_, err := q.db.Exec(ctx, updateThread, arg.Title, arg.Body, arg.ID)
	return err
}
